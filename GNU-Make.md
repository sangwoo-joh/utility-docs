# GNU Make


## 묵시적 규칙 사용하기
 타겟 파일을 만들기 위한 어떤 표준적인 방법은 아주 자주 쓰인다. 예를
 들어, 오브젝트 파일을 만들기 위한 관습적인 방식 중 하나는 C 소스
 파일에 C 컴파일러 `cc`를 이용하는 것이다.

 *묵시적 규칙*은 `make` 에게 이런 관습적인 기술을 사용하는 방법을
 알려주어서, 관습적인 작업을 할 경우 규칙을 자세히 지정할 필요가
 없다. 예를 들면 C 컴파일을 위한 묵시적 규칙이 있다. 파일 이름이 어떤
 묵시적 규칙을 수행할지 결정한다. 예를 들어, C 컴파일은 보통 `.c` 파일
 하나를 가지고 `.o` 파일 하나를 만든다. 그래서 `make`는 이런 파일
 이름을 발견하면 C 컴파일을 위한 묵시적 규칙을 적용한다.

 일련의 묵시적 규칙을 순서대로 적용할 수도 있다. 예를 들어, `make`는
 `.y` 파일로부터 `.c` 파일을 경유해서 `.o` 파일을 다시 만든다.

 내장된 묵시적 규칙은 레시피를 위해 몇몇 변수를 사용하는데, 그래서 이
 변수의 값을 바꾸면, 묵시적 규칙의 동작을 바꿀 수 있다. 예를 들어,
 `CFLAGS` 변수는 C 컴파일 시에 묵시적으로 C 컴파일러에 넘겨주는 플래그
 값이다.


### 묵시적 규칙 사용하기
 타겟 파일을 업데이트 하기 위해서 관습적인 방법을 사용하려면,
 *레시피를 직접 적지 않으면 된다*. 즉, 레시피가 없는 규칙을 적거나,
 혹은 아예 규칙 자체를 적지 않으면 된다. 그러면 `make`가 소스 파일의
 종류에 따라 어떤 묵시적 규칙을 사용할지 찾아낸다.

 예를 들어, 다음과 같은 Makefile이 있다고 하자.

```makefile
foo : foo.o bar.o
	cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
```

 전제조건에 `foo.o` 를 적었지만 이것을 만들기 위한 규칙을 주지 않았기
 때문에, `make`는 자동으로 이를 어떻게 업데이트 할지를 알려주는 묵시적
 규칙을 찾는다. 이 동작은 `foo.o` 파일이 현재 존재하는지 여부에
 상관없이 일어난다.

 만약 묵시적 규칙을 발견하면, 레시피와 하나 이상의 전제조건 (소스
 파일) 모두에 쓰일 수 있다. 묵시적 규칙이 제공할 수 없는 헤더 파일과
 같은 추가적인 전제조건을 지정해야 한다면, 레시피 없이 `foo.o`에 대한
 규칙을 작성할 것이다.

 각각의 묵시적 규칙은 타겟과 전제조건을 위한 패턴을 갖는다. 같은 타겟
 패턴을 갖는 많은 묵시적 규칙이 있을 수 있다. 예를 들어, 많은 규칙이
 `.o` 파일을 만들기 위한 것이다. `.c` 파일에 C 컴파일러를 호출하거나,
 `.p` 파일에 파스칼 컴파일러를 호출하거나, 등등. 실제로 적용하는
 규칙은 전제조건이 있거나 혹은 전제조건을 만들 수 있는 것이다. 그래서,
 만약 `foo.c` 파일이 있으면, `make`는 C 컴파일러를 호출하고, 그렇지
 않은 경우, 만약 `foo.p` 파일이 있다면, `make`는 파스칼 컴파일러를
 호출한다.

 위에서 "전제조건이 있거나 혹은 전제조건을 만들 수 있는" 경우에 묵시적
 규칙을 적용한다고 하였다. Makefile에 타겟이나 전제조건을 명시적으로
 적은 경우, 또는 묵시적 규칙을 재귀적으로 적용해서 만들 수 있는 경우,
 파일을 "만들 수 있다". 묵시적 전제조건이 다른 묵시적 규칙의 결과인
 경우, *체이닝*이 일어난다.


### 내장 규칙 목록
 아래 규칙은 POSIX 기반 시스템에서만 사용할 수 있다. 다른 운영체제의
 내장 규칙을 보려면 Makefile이 없는 디렉토리에서 `make -p`를 실행하면
 목록을 볼 수 있다.


#### C 프로그램 컴파일
 `n.c` 파일로부터 자동으로 `n.o` 파일을 만들며, 레시피는 다음과 같다.

```makefile
$(CC) $(CPPFLAGS) $(CFLAGS) -c
```

#### C++ 프로그램 컴파일
 `n.cc`, `n.cpp`, `n.C` 파일로부터 자동으로 `n.o` 파일을 만들며, 레시피는 다음과 같다.

```makefile
$(CXX) $(CPPFLAGS) $(CXXFLAG) -c
```

#### 어셈블리와 어셈블러 전처리
 `n.s` 파일로부터 자동으로 어셈블러 `as` 를 실행하여 `n.o` 파일을
 만들며, 정확한 레시피는 다음과 같다.

``` makefile
$(AS) $(ASFLAGS)
```

 `n.s` 파일은 `n.S` 파일에 C 전처리기 `cpp`를 호출하여 자동으로
 만들어진다. 레시피는 다음과 같다.

``` makefile
$(CPP) $(CPPFLAGS)
```


#### 오브젝트 링킹
 `n.o` 파일로부터 C 컴파일러를 통해 링커(보통 `ld`)를 호출하여
 자동으로 `n` 을 만든다. 정확한 레시피는 다음과 같다.

``` makefile
$(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)
```

 이 규칙은 하나의 소스 파일로만 구성된 간단한 프로그램을 만들기 위한
 규칙이다. 오브젝트 파일이 여럿이고, 각각의 이름이 실행 파일과 짝이
 맞을 때에도 동작한다. 그러므로,

``` makefile
x: y.o z.o
```

 이런 규칙이 있고 `x.c`, `y.c`, `z.c` 파일이 존재하면,

``` makefile
cc -c x.c -o x.o
cc -c y.c -o y.o
cc -c z.c -o z.o
cc x.o y.o z.o -o x
rm -f x.o
rm -f y.o
rm -f z.o
```

 를 수행한다.
